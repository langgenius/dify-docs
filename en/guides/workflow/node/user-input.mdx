---
title: User Input
---

## Introduction

The User Input node is a type of Start node where you can define what information to collect from end users when they run your application.

Applications starting with this node run *on demand*, initiated by user interaction or API calls. You can publish them as standalone web apps or MCP servers, access them via backend service APIs, or use them as tools within other Dify applications.

## Input Variables

You can configure custom input fields in the User Input node to collect information from users. Each input field becomes a variable that can be referenced by any downstream node. For example, if you add an input field with the variable name `user_name`, you can reference it as `{{user_name}}`.

There are seven input field types you can choose from to handle different kinds of information.

<Info>
    Label names are displayed to users when your application is published as a web app.
</Info>

<Tip>
    You can **Hide** any input variable to exclude it from the user interface. The hidden variable will not be visible to the end-user but remains available as a variable within your chatflows. This feature is only available for chatflow applications.
</Tip>

### Text Inputs

<Tabs>

    <Tab title="Short Text">
    Short Text accepts up to 256 characters. Use this for names, email addresses, titles, or any brief text input that fits on a single line.
    </Tab>

    <Tab title="Paragraph">
    Paragraph accepts long-form text without length restrictions. This gives users a multi-line text area for detailed responses or descriptions.
    </Tab>
</Tabs>

### Structured Inputs

<Tabs>

    <Tab title="Select">
    Select presents users with a dropdown menu of predefined options. Users can only choose from the options you specify, ensuring data consistency and preventing unexpected inputs.
    </Tab>

    <Tab title="Number">
    Number restricts input to numerical values only. It's ideal for quantities, ratings, IDs, or any data you need to process mathematically.
    </Tab>

    <Tab title="Checkbox">
    Checkbox provides users with a simple yes/no option. When a user checks the box, the output is `true`; otherwise, it is `false`. Use it for confirmations or any scenario where a binary choice is needed. 
    </Tab>
</Tabs>

### File Inputs

<Tabs>
    <Tab title="Single File">
    Single File allows users to upload one file of any supported type. Users can either upload from their device or provide a URL to the file. The file becomes available as a file variable containing file metadata (name, size, type, etc.)
    </Tab>

    <Tab title="File List">
    File List works like Single File but supports multiple file uploads at once. It's useful for processing batches of documents, images, or other files together.
    <Tip>
        You can use a List Operator node to filter, sort, or extract specific files from the uploaded file list for further processing.
    </Tip>
    </Tab>
</Tabs>

#### Process Files

Files uploaded through the Start node must be processed appropriately in subsequent nodes. The Start node only collects files; it does not read their content.

Therefore, you'll need to connect specific nodes to extract and process the file content. For example:

- Document files should be routed to a Document Extractor node for text extraction so that LLMs can understand their content.
- Images can be sent to LLM nodes with vision capabilities or specialized image processing tools.
- Structured data files like CSV or JSON can be processed with Code nodes to parse and transform the data.

<Tip>
    When users upload multiple files with mixed types (e.g., images and documents), you can use a List Operator node to separate them by file type before routing them to appropriate processing branches.
</Tip>

## What's Next

After setting up the Start node, you'll typically connect it to other nodes that process the collected user input. Common patterns include:

- Send the input to an LLM node for processing.
- Use a Knowledge Retrieval node to find relevant information based on the input.
- Route the execution path to different branches with conditional logic based on the input.
