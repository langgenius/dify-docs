---
title: "User Input"
description: "Collects user inputs to start workflow and chatflow applications"
icon: "input-text"
---
## Introduction

The User Input node allows you to define what to collect from end users as inputs for your applications.

Applications that start with this node run *on demand* and can be initiated by direct user interaction or API calls. 

You can also publish these applications as standalone web apps or MCP servers, expose them through backend service APIs, or use them as tools in other Dify applications.

<Info>
    Each application canvas can contain only one User Input node.
</Info>

## Input Variable

### Preset

Preset input variables are system-defined and available by default.

- `userinput.files`: Files uploaded by end users when they run the application.

    <Note>
        For workflow applications, this preset variable has been considered *legacy* and kept only for backward compatibility. 

        We recommend using a [custom file input field](#file-input) instead to collect user files.
    </Note>

- `userinput.query` (for chatflows only): The text message automatically captured from the user's latest chat turn.

### Custom

You can configure custom input fields in a User Input node to collect different kinds of user input. Each field becomes a variable that can be referenced by downstream nodes. 

<Info>
    **Label Name** is displayed to your end users.
</Info>

<Tip>
    In a chatflow application, you can **Hide** any user input field to make it invisible to end users while keeping it available for reference within the chatflow. 
    
    Note that a **Required** field cannot be hidden.
</Tip>

#### Text Input

<Tabs>

    <Tab title="Short Text">
    Accepts up to 256 characters. Use it for names, email addresses, titles, or any brief text input that fits on a single line.
    </Tab>

    <Tab title="Paragraph">
    Allows long-form text without length restrictions. It gives users a multi-line text area for detailed responses or descriptions.
    </Tab>
</Tabs>

#### Structured Input

<Tabs>

    <Tab title="Select">
    Displays a dropdown menu with predefined options. Users can choose only from listed options, ensuring data consistency and preventing invalid inputs.
    </Tab>

    <Tab title="Number">
    Restricts input to numerical values only—ideal for quantities, ratings, IDs, or any data requiring mathematical processing.
    </Tab>

    <Tab title="Checkbox">
    Provides a simple yes/no option. When a user checks the box, the output is `true`; otherwise, it's `false`. Use it for confirmations or any case that requires a binary choice. 
    </Tab>

    <Tab title="JSON Code">
    Accepts data in JSON object format, ideal for passing complex, nested data structures into your application.

    You can optionally define a JSON schema to validate the input and guide end users on the expected structure and validation requirements. This also allows you to reference individual properties of the object in other nodes.
    </Tab>
</Tabs>

#### File Input

<Tabs>
    <Tab title="Single File">
    Allows users to upload one file of any supported type, either from their device or via a file URL. The uploaded file is available as a variable containing file metadata (name, size, type, etc.).
    </Tab>

    <Tab title="File List">
    Supports multiple file uploads at once. It's useful for handling batches of documents, images, or other files together.
    
    <Tip>
        Use a List Operator node to filter, sort, or extract specific files from the uploaded file list for further processing.
    </Tip>
    </Tab>
</Tabs>

**File Processing**

Since the User Input node only collects files—it does not read or parse their content—uploaded files must be processed appropriately by subsequent nodes. For example:

- Document files can be routed to a Doc Extractor node for text extraction so that LLMs can understand their content.

- Images can be sent to LLM nodes with vision capabilities or specialized image processing tool nodes.

- Structured data files such as CSV or JSON can be processed with Code nodes to parse and transform the data.

<Tip>
    When users upload multiple files with mixed types (e.g., images and documents), you can use a List Operator node to separate them by file type before routing them to different processing branches.
</Tip>

## What's Next

After setting up a User Input node, you can connect it to other nodes to process the collected data. Common patterns include:

- Send the input to an LLM node for processing.

- Use a Knowledge Retrieval node to find information relevant to the input.

- Create conditional branches based on the input with an If/Else node.