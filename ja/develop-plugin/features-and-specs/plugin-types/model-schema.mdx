---
dimensions:
  type:
    primary: reference
    detail: core
  level: intermediate
standard_title: Model Schema
language: ja
title: モデルAPIインターフェース
description: LLM、TextEmbedding、Rerank、Speech2text、Text2speechモデルの実装要件を含むDifyモデルプラグインAPIの包括的なガイド。すべての関連データ構造の詳細な仕様を含みます。
---

<Note> ⚠️ このドキュメントはAIによって自動翻訳されています。不正確な部分がある場合は、[英語版](/en/develop-plugin/features-and-specs/plugin-types/model-schema)を参照してください。</Note>

## はじめに

このドキュメントでは、Difyモデルプラグインを実装するために必要なインターフェースとデータ構造について詳しく説明します。AIモデルをDifyプラットフォームと統合する開発者向けの技術リファレンスとして機能します。

<Note>
このAPIリファレンスに入る前に、概念的な理解のために[モデル設計ルール](/ja/develop-plugin/features-and-specs/plugin-types/model-designing-rules)と[モデルプラグイン入門](/ja/develop-plugin/features-and-specs/plugin-types/model-designing-rules)を先に読むことをお勧めします。
</Note>

<CardGroup cols={2}>
  <Card title="プロバイダー実装" icon="plug" href="#model-provider">
    異なるAIサービスプロバイダー向けのモデルプロバイダークラスの実装方法を学ぶ
  </Card>
  <Card title="モデルタイプ" icon="layer-group" href="#models">
    5つのサポートされているモデルタイプの実装詳細：LLM、Embedding、Rerank、Speech2Text、Text2Speech
  </Card>
  <Card title="データ構造" icon="database" href="#entities">
    モデルAPIで使用されるすべてのデータ構造の包括的なリファレンス
  </Card>
  <Card title="エラーハンドリング" icon="triangle-exclamation" href="#common-interfaces">
    適切なエラーマッピングと例外処理のガイドライン
  </Card>
</CardGroup>

## モデルプロバイダー

すべてのモデルプロバイダーは`__base.model_provider.ModelProvider`基底クラスを継承し、認証情報検証インターフェースを実装する必要があります。

### プロバイダー認証情報検証

<CodeGroup>
```python Core Implementation
def validate_provider_credentials(self, credentials: dict) -> None:
    """
    Validate provider credentials by making a test API call
    
    Parameters:
        credentials: Provider credentials as defined in `provider_credential_schema`
        
    Raises:
        CredentialsValidateFailedError: If validation fails
    """
    try:
        # Example implementation - validate using an LLM model instance
        model_instance = self.get_model_instance(ModelType.LLM)
        model_instance.validate_credentials(
            model="example-model", 
            credentials=credentials
        )
    except Exception as ex:
        logger.exception(f"Credential validation failed")
        raise CredentialsValidateFailedError(f"Invalid credentials: {str(ex)}")
```

```python Custom Model Provider
class XinferenceProvider(Provider):
    def validate_provider_credentials(self, credentials: dict) -> None:
        """
        For custom-only model providers, a simple implementation is sufficient
        as validation happens at the model level
        """
        pass
```
</CodeGroup>

<ParamField path="credentials" type="dict">
  プロバイダーのYAML設定の`provider_credential_schema`で定義された認証情報。
  通常、`api_key`、`organization_id`などのフィールドを含みます。
</ParamField>

<Warning>
検証が失敗した場合、実装は`CredentialsValidateFailedError`例外をスローする必要があります。これにより、Dify UIで適切なエラーハンドリングが保証されます。
</Warning>

<Tip>
事前定義されたモデルプロバイダーの場合、認証情報がAPIで機能することを検証する徹底的な検証メソッドを実装する必要があります。カスタムモデルプロバイダー（各モデルが独自の認証情報を持つ場合）では、簡略化された実装で十分です。
</Tip>

## モデル

Difyは5つの異なるモデルタイプをサポートしており、それぞれ特定のインターフェースの実装が必要です。ただし、すべてのモデルタイプにはいくつかの共通要件があります。

### 共通インターフェース

タイプに関係なく、すべてのモデル実装はこれら2つの基本メソッドを実装する必要があります：

#### 1. モデル認証情報検証

<CodeGroup>
```python Implementation
def validate_credentials(self, model: str, credentials: dict) -> None:
    """
    Validate that the provided credentials work with the specified model
    
    Parameters:
        model: The specific model identifier (e.g., "gpt-4")
        credentials: Authentication details for the model
        
    Raises:
        CredentialsValidateFailedError: If validation fails
    """
    try:
        # Make a lightweight API call to verify credentials
        # Example: List available models or check account status
        response = self._api_client.validate_api_key(credentials["api_key"])
        
        # Verify the specific model is available if applicable
        if model not in response.get("available_models", []):
            raise CredentialsValidateFailedError(f"Model {model} is not available")
            
    except ApiException as e:
        raise CredentialsValidateFailedError(str(e))
```
</CodeGroup>

<ParamField path="model" type="string" required>
  検証する特定のモデル識別子（例：「gpt-4」、「claude-3-opus」）
</ParamField>

<ParamField path="credentials" type="dict" required>
  プロバイダーの設定で定義された認証情報
</ParamField>

#### 2. エラーマッピング

<CodeGroup>
```python Implementation
@property
def _invoke_error_mapping(self) -> dict[type[InvokeError], list[type[Exception]]]:
    """
    Map provider-specific exceptions to standardized Dify error types
    
    Returns:
        Dictionary mapping Dify error types to lists of provider exception types
    """
    return {
        InvokeConnectionError: [
            requests.exceptions.ConnectionError,
            requests.exceptions.Timeout,
            ConnectionRefusedError
        ],
        InvokeServerUnavailableError: [
            ServiceUnavailableError,
            HTTPStatusError
        ],
        InvokeRateLimitError: [
            RateLimitExceededError,
            QuotaExceededError
        ],
        InvokeAuthorizationError: [
            AuthenticationError,
            InvalidAPIKeyError,
            PermissionDeniedError
        ],
        InvokeBadRequestError: [
            InvalidRequestError,
            ValidationError
        ]
    }
```
</CodeGroup>

<Accordion title="利用可能なエラータイプ">
  <ParamField path="InvokeConnectionError" type="class">
    ネットワーク接続の失敗、タイムアウト
  </ParamField>
  <ParamField path="InvokeServerUnavailableError" type="class">
    サービスプロバイダーがダウンまたは利用不可
  </ParamField>
  <ParamField path="InvokeRateLimitError" type="class">
    レート制限またはクォータ制限に到達
  </ParamField>
  <ParamField path="InvokeAuthorizationError" type="class">
    認証または権限の問題
  </ParamField>
  <ParamField path="InvokeBadRequestError" type="class">
    無効なパラメータまたはリクエスト
  </ParamField>
</Accordion>

<Tip>
エラーマッピングに依存する代わりに、コード内でこれらの標準化されたエラータイプを直接スローすることもできます。このアプローチにより、エラーメッセージをより細かく制御できます。
</Tip>

### LLM実装

大規模言語モデルプロバイダーを実装するには、`__base.large_language_model.LargeLanguageModel`基底クラスを継承し、これらのメソッドを実装します：

#### 1. モデル呼び出し

このコアメソッドは、言語モデルへのストリーミングおよび非ストリーミングAPI呼び出しの両方を処理します。

<CodeGroup>
```python Core Implementation
def _invoke(
    self, 
    model: str, 
    credentials: dict,
    prompt_messages: list[PromptMessage], 
    model_parameters: dict,
    tools: Optional[list[PromptMessageTool]] = None, 
    stop: Optional[list[str]] = None,
    stream: bool = True, 
    user: Optional[str] = None
) -> Union[LLMResult, Generator[LLMResultChunk, None, None]]:
    """
    Invoke the language model
    """
    # Prepare API parameters
    api_params = self._prepare_api_parameters(
        model, 
        credentials, 
        prompt_messages, 
        model_parameters,
        tools, 
        stop
    )
    
    try:
        # Choose between streaming and non-streaming implementation
        if stream:
            return self._invoke_stream(model, api_params, user)
        else:
            return self._invoke_sync(model, api_params, user)
            
    except Exception as e:
        # Map errors using the error mapping property
        self._handle_api_error(e)

# Helper methods for streaming and non-streaming calls
def _invoke_stream(self, model, api_params, user):
    # Implement streaming call and yield chunks
    pass
    
def _invoke_sync(self, model, api_params, user):
    # Implement synchronous call and return complete result
    pass
```
</CodeGroup>

<Accordion title="パラメータ">
  <ParamField path="model" type="string" required>
    モデル識別子（例：「gpt-4」、「claude-3」）
  </ParamField>
  
  <ParamField path="credentials" type="dict" required>
    API用の認証情報
  </ParamField>
  
  <ParamField path="prompt_messages" type="list[PromptMessage]" required>
    Difyの標準化されたフォーマットのメッセージリスト：
    - `completion`モデルの場合：単一の`UserPromptMessage`を含める
    - `chat`モデルの場合：必要に応じて`SystemPromptMessage`、`UserPromptMessage`、`AssistantPromptMessage`、`ToolPromptMessage`を含める
  </ParamField>
  
  <ParamField path="model_parameters" type="dict" required>
    モデルのYAML設定で定義されたモデル固有のパラメータ（temperature、top_pなど）
  </ParamField>
  
  <ParamField path="tools" type="list[PromptMessageTool]">
    関数呼び出し機能のためのツール定義
  </ParamField>
  
  <ParamField path="stop" type="list[string]">
    遭遇時にモデル生成を停止するストップシーケンス
  </ParamField>
  
  <ParamField path="stream" type="boolean" default={true}>
    ストリーミングレスポンスを返すかどうか
  </ParamField>
  
  <ParamField path="user" type="string">
    API監視用のユーザー識別子
  </ParamField>
</Accordion>

<Accordion title="戻り値">
  <ParamField path="stream=True" type="Generator[LLMResultChunk, None, None]">
    利用可能になったレスポンスのチャンクをyieldするジェネレータ
  </ParamField>
  
  <ParamField path="stream=False" type="LLMResult">
    完全な生成テキストを含む完全なレスポンスオブジェクト
  </ParamField>
</Accordion>

<Tip>
コードを整理して保守しやすくするために、ストリーミングと非ストリーミング呼び出し用に別々のヘルパーメソッドを実装することをお勧めします。
</Tip>

#### 2. トークンカウント

<CodeGroup>
```python Implementation
def get_num_tokens(
    self, 
    model: str, 
    credentials: dict, 
    prompt_messages: list[PromptMessage],
    tools: Optional[list[PromptMessageTool]] = None
) -> int:
    """
    Calculate the number of tokens in the prompt
    """
    # Convert prompt_messages to the format expected by the tokenizer
    text = self._convert_messages_to_text(prompt_messages)
    
    try:
        # Use the appropriate tokenizer for this model
        tokenizer = self._get_tokenizer(model)
        return len(tokenizer.encode(text))
    except Exception:
        # Fall back to a generic tokenizer
        return self._get_num_tokens_by_gpt2(text)
```
</CodeGroup>

<Info>
モデルがトークナイザーを提供していない場合、基底クラスの`_get_num_tokens_by_gpt2(text)`メソッドを使用して妥当な近似値を得ることができます。
</Info>

#### 3. カスタムモデルスキーマ（オプション）

<CodeGroup>
```python Implementation
def get_customizable_model_schema(
    self, 
    model: str, 
    credentials: dict
) -> Optional[AIModelEntity]:
    """
    Get parameter schema for custom models
    """
    # For fine-tuned models, you might return the base model's schema
    if model.startswith("ft:"):
        base_model = self._extract_base_model(model)
        return self._get_predefined_model_schema(base_model)
    
    # For standard models, return None to use the predefined schema
    return None
```
</CodeGroup>

<Info>
このメソッドは、カスタムモデルをサポートするプロバイダーにのみ必要です。カスタムモデルが基本モデルからパラメータルールを継承できるようにします。
</Info>

### TextEmbedding実装

<Info>
テキスト埋め込みモデルは、テキストを意味的な意味を捉える高次元ベクトルに変換し、検索、類似性検索、分類に役立ちます。
</Info>

Text Embeddingプロバイダーを実装するには、`__base.text_embedding_model.TextEmbeddingModel`基底クラスを継承します：

#### 1. コア埋め込みメソッド

<CodeGroup>
```python Implementation
def _invoke(
    self, 
    model: str, 
    credentials: dict,
    texts: list[str], 
    user: Optional[str] = None
) -> TextEmbeddingResult:
    """
    Generate embedding vectors for multiple texts
    """
    # Set up API client with credentials
    client = self._get_client(credentials)
    
    # Handle batching if needed
    batch_size = self._get_batch_size(model)
    all_embeddings = []
    total_tokens = 0
    start_time = time.time()
    
    # Process in batches to avoid API limits
    for i in range(0, len(texts), batch_size):
        batch = texts[i:i+batch_size]
        
        # Make API call to the embeddings endpoint
        response = client.embeddings.create(
            model=model,
            input=batch,
            user=user
        )
        
        # Extract embeddings from response
        batch_embeddings = [item.embedding for item in response.data]
        all_embeddings.extend(batch_embeddings)
        
        # Track token usage
        total_tokens += response.usage.total_tokens
    
    # Calculate usage metrics
    elapsed_time = time.time() - start_time
    usage = self._create_embedding_usage(
        model=model,
        tokens=total_tokens,
        latency=elapsed_time
    )
    
    return TextEmbeddingResult(
        model=model,
        embeddings=all_embeddings,
        usage=usage
    )
```
</CodeGroup>

<Accordion title="パラメータ">
  <ParamField path="model" type="string" required>
    埋め込みモデル識別子
  </ParamField>
  
  <ParamField path="credentials" type="dict" required>
    埋め込みサービス用の認証情報
  </ParamField>
  
  <ParamField path="texts" type="list[string]" required>
    埋め込むテキスト入力のリスト
  </ParamField>
  
  <ParamField path="user" type="string">
    API監視用のユーザー識別子
  </ParamField>
</Accordion>

<Accordion title="戻り値">
  <ParamField path="TextEmbeddingResult" type="object" required>
    以下を含む構造化されたレスポンス：
    - model：埋め込みに使用されたモデル
    - embeddings：入力テキストに対応する埋め込みベクトルのリスト
    - usage：トークン使用量とコストに関するメタデータ
  </ParamField>
</Accordion>

#### 2. トークンカウントメソッド

<CodeGroup>
```python Implementation
def get_num_tokens(
    self, 
    model: str, 
    credentials: dict, 
    texts: list[str]
) -> int:
    """
    Calculate the number of tokens in the texts to be embedded
    """
    # Join all texts to estimate token count
    combined_text = " ".join(texts)
    
    try:
        # Use the appropriate tokenizer for this model
        tokenizer = self._get_tokenizer(model)
        return len(tokenizer.encode(combined_text))
    except Exception:
        # Fall back to a generic tokenizer
        return self._get_num_tokens_by_gpt2(combined_text)
```
</CodeGroup>

<Tip>
埋め込みモデルでは、正確なトークンカウントはコスト見積もりに重要ですが、機能性には重要ではありません。`_get_num_tokens_by_gpt2`メソッドはほとんどのモデルに対して妥当な近似値を提供します。
</Tip>

### Rerank実装

<Info>
リランキングモデルは、通常初期検索フェーズの後、クエリとの関連性に基づいて候補ドキュメントのセットを再順序付けすることで検索品質を向上させます。
</Info>

Rerankingプロバイダーを実装するには、`__base.rerank_model.RerankModel`基底クラスを継承します：

<CodeGroup>
```python Implementation
def _invoke(
    self, 
    model: str, 
    credentials: dict,
    query: str, 
    docs: list[str], 
    score_threshold: Optional[float] = None, 
    top_n: Optional[int] = None,
    user: Optional[str] = None
) -> RerankResult:
    """
    Rerank documents based on relevance to the query
    """
    # Set up API client with credentials
    client = self._get_client(credentials)
    
    # Prepare request data
    request_data = {
        "query": query,
        "documents": docs,
    }
    
    # Call reranking API endpoint
    response = client.rerank(
        model=model,
        **request_data,
        user=user
    )
    
    # Process results
    ranked_results = []
    for i, result in enumerate(response.results):
        # Create RerankDocument for each result
        doc = RerankDocument(
            index=result.document_index,  # Original index in docs list
            text=docs[result.document_index],  # Original text
            score=result.relevance_score  # Relevance score
        )
        ranked_results.append(doc)
    
    # Sort by score in descending order
    ranked_results.sort(key=lambda x: x.score, reverse=True)
    
    # Apply score threshold filtering if specified
    if score_threshold is not None:
        ranked_results = [doc for doc in ranked_results if doc.score >= score_threshold]
    
    # Apply top_n limit if specified
    if top_n is not None and top_n > 0:
        ranked_results = ranked_results[:top_n]
    
    return RerankResult(
        model=model,
        docs=ranked_results
    )
```
</CodeGroup>

<Accordion title="パラメータ">
  <ParamField path="model" type="string" required>
    リランキングモデル識別子
  </ParamField>
  
  <ParamField path="credentials" type="dict" required>
    API用の認証情報
  </ParamField>
  
  <ParamField path="query" type="string" required>
    検索クエリテキスト
  </ParamField>
  
  <ParamField path="docs" type="list[string]" required>
    リランキングされるドキュメントテキストのリスト
  </ParamField>
  
  <ParamField path="score_threshold" type="float">
    結果をフィルタリングするためのオプションの最小スコア閾値
  </ParamField>
  
  <ParamField path="top_n" type="int">
    返す結果数のオプションの制限
  </ParamField>
  
  <ParamField path="user" type="string">
    API監視用のユーザー識別子
  </ParamField>
</Accordion>

<Accordion title="戻り値">
  <ParamField path="RerankResult" type="object" required>
    以下を含む構造化されたレスポンス：
    - model：リランキングに使用されたモデル
    - docs：index、text、scoreを持つRerankDocumentオブジェクトのリスト
  </ParamField>
</Accordion>

<Warning>
リランキングは計算コストが高くなる可能性があり、特に大きなドキュメントセットでは顕著です。タイムアウトや過度のリソース消費を避けるために、大きなドキュメントコレクションにはバッチ処理を実装してください。
</Warning>

### Speech2Text実装

<Info>
音声テキスト変換モデルは、音声ファイルから話された言語を書かれたテキストに変換し、文字起こしサービス、音声コマンド、アクセシビリティ機能などのアプリケーションを可能にします。
</Info>

Speech-to-Textプロバイダーを実装するには、`__base.speech2text_model.Speech2TextModel`基底クラスを継承します：

<CodeGroup>
```python Implementation
def _invoke(
    self, 
    model: str, 
    credentials: dict,
    file: IO[bytes], 
    user: Optional[str] = None
) -> str:
    """
    Convert speech audio to text
    """
    # Set up API client with credentials
    client = self._get_client(credentials)
    
    try:
        # Determine the file format
        file_format = self._detect_audio_format(file)
        
        # Prepare the file for API submission
        # Most APIs require either a file path or binary data
        audio_data = file.read()
        
        # Call the speech-to-text API
        response = client.audio.transcriptions.create(
            model=model,
            file=("audio.mp3", audio_data),  # Adjust filename based on actual format
            user=user
        )
        
        # Extract and return the transcribed text
        return response.text
        
    except Exception as e:
        # Map to appropriate error type
        self._handle_api_error(e)
        
    finally:
        # Reset file pointer for potential reuse
        file.seek(0)
```

```python Helper Methods
def _detect_audio_format(self, file: IO[bytes]) -> str:
    """
    Detect the audio format based on file header
    """
    # Read the first few bytes to check the file signature
    header = file.read(12)
    file.seek(0)  # Reset file pointer
    
    # Check for common audio format signatures
    if header.startswith(b'RIFF') and header[8:12] == b'WAVE':
        return 'wav'
    elif header.startswith(b'ID3') or header.startswith(b'\xFF\xFB'):
        return 'mp3'
    elif header.startswith(b'OggS'):
        return 'ogg'
    elif header.startswith(b'fLaC'):
        return 'flac'
    else:
        # Default or additional format checks
        return 'mp3'  # Default assumption
```
</CodeGroup>

<Accordion title="パラメータ">
  <ParamField path="model" type="string" required>
    音声テキスト変換モデル識別子
  </ParamField>
  
  <ParamField path="credentials" type="dict" required>
    API用の認証情報
  </ParamField>
  
  <ParamField path="file" type="IO[bytes]" required>
    文字起こしする音声を含むバイナリファイルオブジェクト
  </ParamField>
  
  <ParamField path="user" type="string">
    API監視用のユーザー識別子
  </ParamField>
</Accordion>

<Accordion title="戻り値">
  <ParamField path="text" type="string" required>
    音声ファイルから文字起こしされたテキスト
  </ParamField>
</Accordion>

<Tip>
異なるファイルタイプを適切に処理するためには、音声フォーマットの検出が重要です。例に示すように、ファイルヘッダーからフォーマットを検出するヘルパーメソッドの実装を検討してください。
</Tip>

<Warning>
一部の音声テキスト変換APIにはファイルサイズの制限があります。必要に応じて、大きな音声ファイル用にチャンク処理を実装することを検討してください。
</Warning>

### Text2Speech実装

<Info>
テキスト音声変換モデルは、書かれたテキストを自然な音声に変換し、音声アシスタント、スクリーンリーダー、音声コンテンツ生成などのアプリケーションを可能にします。
</Info>

Text-to-Speechプロバイダーを実装するには、`__base.text2speech_model.Text2SpeechModel`基底クラスを継承します：

<CodeGroup>
```python Implementation
def _invoke(
    self, 
    model: str, 
    credentials: dict, 
    content_text: str, 
    streaming: bool,
    user: Optional[str] = None
) -> Union[bytes, Generator[bytes, None, None]]:
    """
    Convert text to speech audio
    """
    # Set up API client with credentials
    client = self._get_client(credentials)
    
    # Get voice settings based on model
    voice = self._get_voice_for_model(model)
    
    try:
        # Choose implementation based on streaming preference
        if streaming:
            return self._stream_audio(
                client=client,
                model=model,
                text=content_text,
                voice=voice,
                user=user
            )
        else:
            return self._generate_complete_audio(
                client=client,
                model=model,
                text=content_text,
                voice=voice,
                user=user
            )
    except Exception as e:
        self._handle_api_error(e)
```

```python Helper Methods
def _stream_audio(self, client, model, text, voice, user=None):
    """
    Implementation for streaming audio output
    """
    # Make API request with stream=True
    response = client.audio.speech.create(
        model=model,
        voice=voice,
        input=text,
        stream=True,
        user=user
    )
    
    # Yield chunks as they arrive
    for chunk in response:
        if chunk:
            yield chunk
            
def _generate_complete_audio(self, client, model, text, voice, user=None):
    """
    Implementation for complete audio file generation
    """
    # Make API request for complete audio
    response = client.audio.speech.create(
        model=model,
        voice=voice,
        input=text,
        user=user
    )
    
    # Get audio data as bytes
    audio_data = response.content
    return audio_data
```
</CodeGroup>

<Accordion title="パラメータ">
  <ParamField path="model" type="string" required>
    テキスト音声変換モデル識別子
  </ParamField>
  
  <ParamField path="credentials" type="dict" required>
    API用の認証情報
  </ParamField>
  
  <ParamField path="content_text" type="string" required>
    音声に変換するテキストコンテンツ
  </ParamField>
  
  <ParamField path="streaming" type="boolean" required>
    ストリーミング音声を返すか完全なファイルを返すか
  </ParamField>
  
  <ParamField path="user" type="string">
    API監視用のユーザー識別子
  </ParamField>
</Accordion>

<Accordion title="戻り値">
  <ParamField path="streaming=True" type="Generator[bytes, None, None]">
    利用可能になった音声チャンクをyieldするジェネレータ
  </ParamField>
  
  <ParamField path="streaming=False" type="bytes">
    バイトとしての完全な音声データ
  </ParamField>
</Accordion>

<Tip>
ほとんどのテキスト音声変換APIでは、モデルと一緒に音声を指定する必要があります。Difyのモデル識別子とプロバイダーの音声オプション間のマッピングを実装することを検討してください。
</Tip>

<Warning>
長いテキスト入力は、より良い音声合成品質のためにチャンク処理が必要な場合があります。句読点、数字、特殊文字を適切に処理するためのテキスト前処理の実装を検討してください。
</Warning>


### Moderation実装

<Info>
モデレーションモデルは、潜在的に有害、不適切、または安全でないコンテンツについてコンテンツを分析し、プラットフォームの安全性とコンテンツポリシーの維持を支援します。
</Info>

Moderationプロバイダーを実装するには、`__base.moderation_model.ModerationModel`基底クラスを継承します：

<CodeGroup>
```python Implementation
def _invoke(
    self, 
    model: str, 
    credentials: dict,
    text: str, 
    user: Optional[str] = None
) -> bool:
    """
    Analyze text for harmful content
    
    Returns:
        bool: False if the text is safe, True if it contains harmful content
    """
    # Set up API client with credentials
    client = self._get_client(credentials)
    
    try:
        # Call moderation API
        response = client.moderations.create(
            model=model,
            input=text,
            user=user
        )
        
        # Check if any categories were flagged
        result = response.results[0]
        
        # Return True if flagged in any category, False if safe
        return result.flagged
        
    except Exception as e:
        # Log the error but default to safe if there's an API issue
        # This is a conservative approach - production systems might want
        # different fallback behavior
        logger.error(f"Moderation API error: {str(e)}")
        return False
```

```python Detailed Implementation
def _invoke(
    self, 
    model: str, 
    credentials: dict,
    text: str, 
    user: Optional[str] = None
) -> bool:
    """
    Analyze text for harmful content with detailed category checking
    """
    # Set up API client with credentials
    client = self._get_client(credentials)
    
    try:
        # Call moderation API
        response = client.moderations.create(
            model=model,
            input=text,
            user=user
        )
        
        # Get detailed category results
        result = response.results[0]
        categories = result.categories
        
        # Check specific categories based on your application's needs
        # For example, you might want to flag certain categories but not others
        critical_violations = [
            categories.harassment,
            categories.hate,
            categories.self_harm,
            categories.sexual,
            categories.violence
        ]
        
        # Flag content if any critical category is violated
        return any(critical_violations)
        
    except Exception as e:
        self._handle_api_error(e)
        # Default to safe in case of error
        return False
```
</CodeGroup>

<Accordion title="パラメータ">
  <ParamField path="model" type="string" required>
    モデレーションモデル識別子
  </ParamField>
  
  <ParamField path="credentials" type="dict" required>
    API用の認証情報
  </ParamField>
  
  <ParamField path="text" type="string" required>
    分析するテキストコンテンツ
  </ParamField>
  
  <ParamField path="user" type="string">
    API監視用のユーザー識別子
  </ParamField>
</Accordion>

<Accordion title="戻り値">
  <ParamField path="result" type="boolean" required>
    コンテンツの安全性を示すブール値：
    - False：コンテンツは安全
    - True：コンテンツに有害な素材が含まれている
  </ParamField>
</Accordion>

<Warning>
モデレーションは安全機構として使用されることが多いです。ソリューションを実装する際は、偽陰性（有害なコンテンツを通過させる）と偽陽性（安全なコンテンツをブロックする）の影響を考慮してください。
</Warning>

<Tip>
多くのモデレーションAPIは、単なるバイナリ結果ではなく、詳細なカテゴリスコアを提供します。アプリケーションで必要な場合は、有害なコンテンツの特定のカテゴリに関するより詳細な情報を返すようにこの実装を拡張することを検討してください。
</Tip>

### エンティティ

#### PromptMessageRole

メッセージロール

```python
class PromptMessageRole(Enum):
    """
    Enum class for prompt message.
    """
    SYSTEM = "system"
    USER = "user"
    ASSISTANT = "assistant"
    TOOL = "tool"
```

#### PromptMessageContentType

メッセージコンテンツタイプ、プレーンテキストと画像に分かれます。

```python
class PromptMessageContentType(Enum):
    """
    Enum class for prompt message content type.
    """
    TEXT = 'text'
    IMAGE = 'image'
```

#### PromptMessageContent

メッセージコンテンツ基底クラス、パラメータ宣言のみに使用され、初期化できません。

```python
class PromptMessageContent(BaseModel):
    """
    Model class for prompt message content.
    """
    type: PromptMessageContentType
    data: str  # Content data
```

現在、テキストと画像の2種類をサポートしており、テキストと複数の画像を同時にサポートできます。
`TextPromptMessageContent`と`ImagePromptMessageContent`を別々に初期化する必要があります。

#### TextPromptMessageContent

```python
class TextPromptMessageContent(PromptMessageContent):
    """
    Model class for text prompt message content.
    """
    type: PromptMessageContentType = PromptMessageContentType.TEXT
```

テキストと画像を渡す場合、テキストは`content`リストの一部としてこのエンティティとして構築する必要があります。

#### ImagePromptMessageContent

```python
class ImagePromptMessageContent(PromptMessageContent):
    """
    Model class for image prompt message content.
    """
    class DETAIL(Enum):
        LOW = 'low'
        HIGH = 'high'

    type: PromptMessageContentType = PromptMessageContentType.IMAGE
    detail: DETAIL = DETAIL.LOW  # Resolution
```

テキストと画像を渡す場合、画像は`content`リストの一部としてこのエンティティとして構築する必要があります。
`data`は`url`または画像の`base64`エンコードされた文字列にすることができます。

#### PromptMessage

すべてのロールメッセージボディの基底クラス、パラメータ宣言のみに使用され、初期化できません。

```python
class PromptMessage(ABC, BaseModel):
    """
    Model class for prompt message.
    """
    role: PromptMessageRole  # Message role
    content: Optional[str | list[PromptMessageContent]] = None  # Supports two types: string and content list. The content list is for multimodal needs, see PromptMessageContent for details.
    name: Optional[str] = None  # Name, optional.
```

#### UserPromptMessage

UserMessageメッセージボディ、ユーザーメッセージを表します。

```python
class UserPromptMessage(PromptMessage):
    """
    Model class for user prompt message.
    """
    role: PromptMessageRole = PromptMessageRole.USER
```

#### AssistantPromptMessage

モデル応答メッセージを表し、通常`few-shots`またはチャット履歴入力に使用されます。

```python
class AssistantPromptMessage(PromptMessage):
    """
    Model class for assistant prompt message.
    """
    class ToolCall(BaseModel):
        """
        Model class for assistant prompt message tool call.
        """
        class ToolCallFunction(BaseModel):
            """
            Model class for assistant prompt message tool call function.
            """
            name: str  # Tool name
            arguments: str  # Tool parameters

        id: str  # Tool ID, only effective for OpenAI tool call, a unique ID for tool invocation, the same tool can be called multiple times
        type: str  # Default is function
        function: ToolCallFunction  # Tool call information

    role: PromptMessageRole = PromptMessageRole.ASSISTANT
    tool_calls: list[ToolCall] = []  # Model's tool call results (only returned when tools are passed in and the model decides to call them)
```

ここで`tool_calls`は、モデルに`tools`を渡した後にモデルが返す`tool call`のリストです。

#### SystemPromptMessage

システムメッセージを表し、通常モデルのシステム指示を設定するために使用されます。

```python
class SystemPromptMessage(PromptMessage):
    """
    Model class for system prompt message.
    """
    role: PromptMessageRole = PromptMessageRole.SYSTEM
```

#### ToolPromptMessage

ツールメッセージを表し、ツールが実行された後に次のステップの計画のために結果をモデルに渡すために使用されます。

```python
class ToolPromptMessage(PromptMessage):
    """
    Model class for tool prompt message.
    """
    role: PromptMessageRole = PromptMessageRole.TOOL
    tool_call_id: str  # Tool call ID, if OpenAI tool call is not supported, you can also pass in the tool name
```

基底クラスの`content`にツール実行結果を渡します。

#### PromptMessageTool

```python
class PromptMessageTool(BaseModel):
    """
    Model class for prompt message tool.
    """
    name: str  # Tool name
    description: str  # Tool description
    parameters: dict  # Tool parameters dict

```

***

#### LLMResult

```python
class LLMResult(BaseModel):
    """
    Model class for llm result.
    """
    model: str  # Actually used model
    prompt_messages: list[PromptMessage]  # Prompt message list
    message: AssistantPromptMessage  # Reply message
    usage: LLMUsage  # Tokens used and cost information
    system_fingerprint: Optional[str] = None  # Request fingerprint, refer to OpenAI parameter definition
```

#### LLMResultChunkDelta

ストリーミングレスポンスの各イテレーション内のDeltaエンティティ

```python
class LLMResultChunkDelta(BaseModel):
    """
    Model class for llm result chunk delta.
    """
    index: int  # Sequence number
    message: AssistantPromptMessage  # Reply message
    usage: Optional[LLMUsage] = None  # Tokens used and cost information, only returned in the last message
    finish_reason: Optional[str] = None  # Completion reason, only returned in the last message
```

#### LLMResultChunk

ストリーミングレスポンスのイテレーションエンティティ

```python
class LLMResultChunk(BaseModel):
    """
    Model class for llm result chunk.
    """
    model: str  # Actually used model
    prompt_messages: list[PromptMessage]  # Prompt message list
    system_fingerprint: Optional[str] = None  # Request fingerprint, refer to OpenAI parameter definition
    delta: LLMResultChunkDelta  # Changes in content for each iteration
```

#### LLMUsage

```python
class LLMUsage(ModelUsage):
    """
    Model class for llm usage.
    """
    prompt_tokens: int  # Tokens used by prompt
    prompt_unit_price: Decimal  # Prompt unit price
    prompt_price_unit: Decimal  # Prompt price unit, i.e., unit price based on how many tokens
    prompt_price: Decimal  # Prompt cost
    completion_tokens: int  # Tokens used by completion
    completion_unit_price: Decimal  # Completion unit price
    completion_price_unit: Decimal  # Completion price unit, i.e., unit price based on how many tokens
    completion_price: Decimal  # Completion cost
    total_tokens: int  # Total tokens used
    total_price: Decimal  # Total cost
    currency: str  # Currency unit
    latency: float  # Request time (s)
```

***

#### TextEmbeddingResult

```python
class TextEmbeddingResult(BaseModel):
    """
    Model class for text embedding result.
    """
    model: str  # Actually used model
    embeddings: list[list[float]]  # Embedding vector list, corresponding to the input texts list
    usage: EmbeddingUsage  # Usage information
```

#### EmbeddingUsage

```python
class EmbeddingUsage(ModelUsage):
    """
    Model class for embedding usage.
    """
    tokens: int  # Tokens used
    total_tokens: int  # Total tokens used
    unit_price: Decimal  # Unit price
    price_unit: Decimal  # Price unit, i.e., unit price based on how many tokens
    total_price: Decimal  # Total cost
    currency: str  # Currency unit
    latency: float  # Request time (s)
```

***

#### RerankResult

```python
class RerankResult(BaseModel):
    """
    Model class for rerank result.
    """
    model: str  # Actually used model
    docs: list[RerankDocument]  # List of reranked segments        
```

#### RerankDocument

```python
class RerankDocument(BaseModel):
    """
    Model class for rerank document.
    """
    index: int  # Original sequence number
    text: str  # Segment text content
    score: float  # Score
```

## 関連リソース

- [モデル設計ルール](/ja/develop-plugin/features-and-specs/plugin-types/model-designing-rules) - モデル設定の標準を理解する
- [モデルプラグイン入門](/ja/develop-plugin/features-and-specs/plugin-types/model-designing-rules) - モデルプラグインの基本概念を素早く理解する
- [新しいモデルを素早く統合する](/ja/develop-plugin/dev-guides-and-walkthroughs/creating-new-model-provider) - 既存のプロバイダーに新しいモデルを追加する方法を学ぶ
- [新しいモデルプロバイダーを作成する](/ja/develop-plugin/dev-guides-and-walkthroughs/creating-new-model-provider) - 全く新しいモデルプロバイダーを開発する方法を学ぶ

{/*
Contributing Section
DO NOT edit this section!
It will be automatically generated by the script.
*/}

---

[Edit this page](https://github.com/langgenius/dify-docs/edit/main/en/develop-plugin/features-and-specs/plugin-types/model-schema.mdx) | [Report an issue](https://github.com/langgenius/dify-docs/issues/new?template=docs.yml)